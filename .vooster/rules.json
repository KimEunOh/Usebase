{
  "rules": [
    {
      "type": "prd",
      "content": "# 제품 요구사항 문서 (PRD)\n\n## 1. 요약\n‘Pay-per-use 종합 AI 플랫폼’은 LLM API를 기반으로 조직(시·도 공무원, 기업 단체 등)이 업무 특화 AI 모듈을 팀 단위로 사용하고 실제 사용량만큼만 과금받을 수 있는 웹/데스크톱 서비스다. 문서 기반 RAG, 실시간 검색, OCR, 기획서 작성 자동화 등을 통합 제공해 별도 월정액 없이 효율적·보안성 높은 AI 업무 환경을 제공한다.\n\n## 2. 문제 정의\n- 개별 직원이 서로 다른 AI 서비스에 각각 월정액을 결제 → 비용 중복, 관리 복잡.\n- 공공·기업 조직은 기밀 데이터, 문서를 자체적으로 관리·검색·분석해야 하나, 범용 챗봇은 RAG·보안 기능 부족.\n- LLM 사용비 예측 불가, 예산 확보 어려움 → 실제 사용량만큼 과금 필요.\n- 통합 대시보드 없이 팀·조직별 사용량, 권한, 문서 관리가 단절.\n\n## 3. 목표 및 목적\n- 1차 목표: 팀·조직 단위 RAG+AI 작업 공간 제공, 사용량 기반 과금.\n- 부차 목표:\n  - 문서·데이터 수명주기 관리(추가, 삭제, 전처리, 폴더화)\n  - 맞춤형 AI 모듈(기획서·보고서 자동 작성 등) 제공\n  - 실시간 사용량 통계·비용 예측\n- 성공 지표:\n  - 조직별 월 활성 사용자(MAU) 70% 이상\n  - LLM 호출당 평균 지연시간 1.5초 이하\n  - 고객 이탈률 < 5%/분기\n  - RAG 기반 응답 정확도 만족도 90% 이상\n\n## 4. 대상 사용자\n### 1차 사용자\n- 지방자치단체, 공기업, 중대형 민간기업의 실무자·팀장  \n- 필요: 보안 내재화, 문서 기반 AI 검색/작성, 예산 통제\n### 2차 사용자\n- IT 관리자: 사용자·권한·과금 관리  \n- 경영진: 비용·생산성 리포트  \n- AI 파트너사: API 마켓플레이스 연동\n\n## 5. 사용자 스토리\n- “시청 정책팀 직원으로서, 팀 공유폴더에 올린 조례 PDF를 바로 AI 검색해 초안 보고서를 작성하고 싶다.”\n- “IT 관리자로서, 부서별 AI 사용량과 예상 비용을 월말 전에 파악해 예산을 조정하고 싶다.”\n- “기업 전략담당자로서, 여러 형식의 경쟁사 보고서를 OCR 후 요약해 회의자료를 빠르게 만들고 싶다.”\n\n## 6. 기능 요구사항\n### 핵심 기능\n1. RAG 문서 관리  \n   - 업로드(폴더/드래그), 삭제, 버전관리  \n   - 전처리: OCR·텍스트 추출, 문단 분할, 메타데이터 태깅  \n   - 폴더·태그 기반 검색, 접근권한(조직·팀·개인)\n   - 수락 기준: 1,000쪽 PDF 2분 내 인덱싱, 검색 정확도 ≥ 90%\n2. 대화형 실시간 검색  \n   - 자연어 질문→RAG 답변 + 출처 링크  \n   - 실시간 스트리밍 응답(1초 이내 첫 토큰)\n3. 문서·기획서 자동 작성 모듈  \n   - 템플릿 선택 → 요구사항 입력 → 초안 생성  \n   - 편집기 내 피드백 루프(“수치 업데이트” 등)\n4. OCR 서비스  \n   - 이미지·스캔 PDF 자동 감지, 한글 정확도 ≥ 95%\n5. 사용량·과금 대시보드  \n   - 조직/팀/사용자별 토큰·API 콜, 월 비용 예상  \n   - CSV·PDF 내보내기\n6. 인증·보안  \n   - Supabase Auth (SAML/OAuth) 싱글사인온  \n   - 역할 기반 접근제어(RBAC)  \n   - 데이터 암호화 at-rest, in-transit\n\n### 지원 기능 (Nice-to-have)\n- 워크플로 자동화(예: 문서 업로드→자동 요약→메일 발송)\n- 멀티언어 번역 및 다국어 RAG\n- 음성→텍스트 STT, 회의록 요약\n- 플러그인/마켓: 서드파티 AI 모듈 구독\n\n## 7. 비기능 요구사항\n- 성능: p95 응답 < 2.5초, 동시 세션 5,000\n- 신뢰성: 월 가동률 99.9%\n- 보안: ISMS·ISO27001 준수, 감사 로그 1년 보관\n- 확장성: 멀티테넌트, 워크스페이스 수평 확장\n- 호환성: 최신 Chrome/Edge, Windows 10+ 데스크톱 앱\n\n## 8. 기술 고려사항\n- 프런트엔드: Next.js 15 + TypeScript + Tailwind CSS\n- 백엔드: Supabase(PostgreSQL, Storage, Auth), 파프리카형 LLM API 프록시\n- 벡터 DB: pgvector (PostgreSQL 확장)  \n- 인프라: Vercel(프런트), Supabase + Fly.io(백업 클러스터)\n- 데스크톱: Electron + 동일 React 코드공유\n- 서드파티: OpenAI, AWS Textract(OCR), 한국어 LLM 대안\n- 데이터 거버넌스: 조직별 데이터 스키마 격리\n\n## 9. 성공 지표\n- 기능: 문서 업로드→검색→응답 완료 평균 3분 미만\n- 비즈니스: 첫 6개월 유료 조직 100개, ARPU 30%↑\n- 기술: p99 에러율 < 0.5%, 배포 후 롤백률 < 2%\n\n## 10. 일정 및 마일스톤\n| 단계 | 기간 | 주요 산출물 |\n|---|---|---|\n| Phase 1 MVP | M0–M3 | RAG·검색·대시보드·기본 과금 |\n| Phase 2 확장 | M4–M6 | OCR, 문서 자동작성, SSO, 데스크톱 앱 |\n| Phase 3 고도화 | M7–M9 | 워크플로 자동화, 마켓플레이스, 멀티언어 |\n\n## 11. 위험 및 대응\n- LLM 요금 폭증 → 캐싱·요약·토큰 절감 알고리즘 적용\n- 공공기관 보안 규제 → 온프렘/프라이빗 배포 옵션 준비\n- 사용자 교육 부족 → 인앱 튜토리얼, 정부기관 특화 세미나\n- 벡터 검색 정확도 저하 → 하이브리드 BM25+벡터, 지속적 파인튜닝\n\n## 12. 향후 고려사항\n- 자체 한국어 LLM 파인튜닝으로 비용 절감\n- 모바일 앱 제공, 오프라인 모드 지원\n- AI 거버넌스(편향 모니터링, 감성 필터) 모듈\n- API 마켓플레이스 확대, 서드파티 수익 쉐어 모델\n\n",
      "writedAt": "2025-07-30T04:50:37.895Z"
    },
    {
      "type": "architecture",
      "content": "# Technical Requirements Document (TRD)\n\n## 1. Executive Technical Summary\n\n- **프로젝트 개요**  \n  팀·조직 단위로 문서 기반 RAG, 실시간 검색, OCR, 자동 기획서 작성 등을 제공하며 실제 사용량 기반 과금하는 웹/데스크톱 하이브리드 AI 플랫폼을 구축. Next.js(웹), Electron(데스크톱) 클라이언트와 NestJS 백엔드를 Monorepo로 구성하고, Supabase(PostgreSQL+pgvector+Auth+Storage)와 Redis·Kafka를 통합하여 Layered Architecture 및 AOP 스타일 미들웨어로 보안·로깅·트랜잭션을 처리.\n\n- **핵심 기술 스택**  \n  프런트엔드: Next.js 15 + TypeScript + Tailwind CSS  \n  데스크톱: Electron + React (Next.js 코드 공유)  \n  백엔드: NestJS (Node.js) + TypeScript, RESTful API, AOP 미들웨어  \n  데이터베이스: Supabase PostgreSQL + pgvector 확장, Read Replica  \n  캐시: Redis (LRU 캐시)  \n  메시지 브로커: Kafka  \n  인증/보안: Supabase Auth(SAML/OAuth + 이메일/비번), RBAC, RLS, AES-256/TLS1.2+  \n  인프라: Vercel(프런트), Fly.io(NestJS), Supabase\n\n- **주요 기술 목표**  \n  • p95 응답 시간 < 2.5초, LLM 호출당 평균 지연 < 1.5초  \n  • 동시 세션 5,000 이상 처리, 월 가동률 99.9%  \n  • RAG 검색 정확도 ≥ 90%, OCR 한글 정확도 ≥ 95%  \n  • p99 에러율 < 0.5%, 배포 롤백률 < 2%\n\n- **핵심 기술 가정**  \n  • 주요 LLM API(OpenAI 등) 평균 응답 시간 500ms 내외  \n  • pgvector + IVFFLAT 인덱스로 대용량 벡터 검색 성능 확보  \n  • Supabase RLS 및 RBAC으로 멀티테넌시 보안 분리 가능  \n  • Kafka로 이벤트 기반 비동기 처리 및 확장성 제공\n\n---\n\n## 2. Tech Stack\n\n| Category            | Technology / Library         | Reasoning (선택 이유)                                    |\n| ------------------- | ---------------------------- | -------------------------------------------------------- |\n| Web Frontend        | Next.js 15 + TypeScript      | SSR·CSR 조합, 코드 스플리팅, 성능 최적화                 |\n| Styling             | Tailwind CSS                 | 유틸리티 퍼스트, 빠른 UI 개발                            |\n| Desktop Frontend    | Electron + React             | 기존 React/Next.js 코드 재사용, 크로스플랫폼 데스크톱 지원 |\n| Backend Framework   | NestJS + TypeScript          | AOP 미들웨어, 모듈화된 Layered Architecture              |\n| API Protocol        | RESTful API                  | 표준화된 자원 기반 설계, 확장성 및 호환성                |\n| Database            | Supabase PostgreSQL          | 완전관리형 Postgres, RLS/RBAC, 스토리지 통합            |\n| Vector DB Extension | pgvector + IVFFLAT           | PostgreSQL 내 벡터 검색, 빠른 근사 최근접 이웃 검색      |\n| Cache               | Redis (LRU)                  | Prompt-Response, 비용 요약 캐싱, 높은 처리량             |\n| Message Broker      | Kafka                        | 비동기 이벤트 처리, 확장성, 내결함성                     |\n| Authentication      | Supabase Auth (SAML/OAuth)   | 이메일/비밀번호, 싱글사인온, 조직별 권한 관리             |\n| Storage             | Supabase Storage             | 문서/이미지 파일 관리, 버전관리                          |\n| Infra (Web)         | Vercel                       | Next.js 최적화 배포, 글로벌 CDN                          |\n| Infra (Backend)     | Fly.io                       | 컨테이너 기반 글로벌 배포, 자동 스케일링                  |\n| CI/CD               | GitHub Actions               | Monorepo 빌드·테스트·배포 자동화                        |\n| Monitoring          | Prometheus + Grafana         | 시스템 성능·메트릭 수집 및 시각화                       |\n\n---\n\n## 3. System Architecture Design\n\n### Top-Level Building Blocks\n- **Web Client (Next.js)**  \n  • 페이지 렌더링(SSR/ISR), API 호출, 상태 관리(Redux 또는 SWR)  \n- **Desktop Client (Electron)**  \n  • Next.js Static Bundle 로드, OS 통합(파일 시스템, 알림)  \n- **API Gateway (NestJS)**  \n  • 인증·인가 미들웨어(AOP), 로깅, 에러 처리, 트랜잭션 관리  \n- **Core Services**  \n  • RAG Service: pgvector 검색, 메타데이터 인덱싱  \n  • OCR Service: AWS Textract 연동, 한글 전처리  \n  • Auto-Doc Service: 템플릿 기반 기획서/보고서 생성  \n  • Billing Service: Kafka 이벤트 처리, 비용 집계, Materialized View  \n- **Data Stores**  \n  • Supabase PostgreSQL (Primary + Read Replica)  \n  • Redis 캐시 (Prompt-Response, 요약 결과)  \n  • Kafka 토픽 (Usage Events, Billing Events)\n\n### Top-Level Component Interaction Diagram\n```mermaid\ngraph TD\n  A[Next.js Frontend] -->|REST API| B[NestJS API]\n  C[Electron Desktop] -->|REST API| B\n  B -->|pg & pgvector| D[Supabase PostgreSQL]\n  B -->|Redis| E[Redis Cache]\n  B -->|Kafka| F[Kafka Broker]\n  B -->|S3 API| G[Supabase Storage]\n  B -->|Auth SDK| H[Supabase Auth]\n  B -->|External| I[LLM API / AWS Textract]\n```\n\n- Next.js/Electron 클라이언트가 NestJS API에 REST 요청  \n- API는 Supabase PostgreSQL·Vector, Redis 캐시, Kafka 토픽, 외부 LLM/OCR 서비스와 상호작용  \n- Storage는 문서·이미지 보관, Auth는 SSO 및 RBAC 제공  \n\n### Code Organization & Convention\n\n**도메인 기반 구조**  \n- user-management, document-management, rag-search, ocr, billing, notification 등으로 분리  \n- 각 도메인은 presentation, application, domain, infrastructure 레이어 포함  \n\n**공통 모듈**  \n- shared (유틸, 타입, 인터페이스), config, logger, exception-filter  \n\n**폴더 구조 (Monorepo)**  \n```\n/\n├── apps\n│   ├── web            # Next.js 애플리케이션\n│   └── desktop        # Electron 애플리케이션\n├── services\n│   ├── api            # NestJS 백엔드\n│   ├── worker         # Kafka 이벤트 처리 워커\n│   └── billing        # 비용 집계 마이크로서비스\n├── libs\n│   ├── shared         # 공통 유틸/타입/미들웨어\n│   ├── config         # 환경 설정\n│   └── domain         # 도메인 모델/서비스 인터페이스\n├── infra\n│   ├── terraform      # 인프라 코드\n│   └── kubernetes     # 오케스트레이션 매니페스트\n├── docker-compose.yml\n├── package.json\n└── tsconfig.json\n```\n\n### Data Flow & Communication Patterns\n- **Client-Server 통신**: RESTful API, JWT + SAML/OAuth 토큰 헤더  \n- **DB Interaction**: TypeORM or Prisma 사용, RLS 정책 적용, Soft Delete + Versioning  \n- **캐시 전략**: Redis LRU 캐시(Prompt-Response, 문서 요약), TTL 기반 무효화  \n- **비동기 이벤트**: 사용량·과금 이벤트 Kafka 발행 및 소비, idempotent 처리  \n- **데이터 동기화**: Materialized View로 비용 요약, Read Replica로 읽기 분산  \n\n---\n\n## 4. Performance & Optimization Strategy\n\n- 벡터 검색: pgvector + IVFFLAT, 인덱스 파라미터 튜닝  \n- Redis 캐시: Prompt-Response 및 비용 요약, 높은 히트율 유지  \n- DB Connection Pooling 및 Read Replica 활용으로 동시성 확장  \n- NestJS AOP 미들웨어로 로깅·트랜잭션 비용 최소화  \n- HTTP/2, gzip 압축, ISR/SSR 캐시 전략 적용  \n\n---\n\n## 5. Implementation Roadmap & Milestones\n\n### Phase 1: Foundation (MVP 구현, M0–M3)\n- **Core Infrastructure**: Monorepo 셋업, Vercel/Fly.io 배포 파이프라인  \n- **Essential Features**: 문서 업로드·RAG 인덱싱·검색, 실시간 스트리밍 검색, 기본 과금 대시보드  \n- **Basic Security**: Supabase Auth 이메일/비번, RBAC, RLS 정책  \n- **Dev Setup**: GitHub Actions CI, 코드 린트·테스트 환경  \n- **Timeline**: 3개월\n\n### Phase 2: Feature Enhancement (M4–M6)\n- **Advanced Features**: OCR 통합, 자동 기획서 작성 모듈, CSV/PDF 내보내기  \n- **Performance Tuning**: Redis 캐시, Kafka 이벤트 처리 최적화  \n- **Enhanced Security**: SAML/OAuth SSO, 감사 로그 1년 저장  \n- **Monitoring**: Prometheus·Grafana, 알림 설정  \n- **Timeline**: 3개월\n\n### Phase 3: Scaling & Optimization (M7–M9)\n- **Scalability**: 오토스케일링, 멀티 리전 배포 옵션  \n- **Advanced Integrations**: 서드파티 AI 마켓플레이스, 워크플로 자동화  \n- **Enterprise Features**: 멀티언어 RAG, 음성 인식·회의록 요약  \n- **Compliance**: ISMS·ISO27001 감사 대응  \n- **Timeline**: 3개월\n\n---\n\n## 6. Risk Assessment & Mitigation Strategies\n\n### Technical Risk Analysis\n- **LLM 요금 폭증**  \n  Mitigation: 응답 캐싱, 요약·토큰 절감 알고리즘, 사전 필터링  \n- **보안 규제 (공공기관)**  \n  Mitigation: 온프렘 옵션, 네트워크 격리, 강화된 RLS  \n- **벡터 검색 정확도 저하**  \n  Mitigation: 하이브리드 BM25+pgvector, 주기적 파인튜닝  \n\n### Project Delivery Risks\n- **일정 지연**  \n  Mitigation: 중요 경로 식별, 스파이크 프로토타입 조기 수행  \n- **리소스 부족**  \n  Mitigation: 외부 컨설팅·아웃소싱, 크로스 트레이닝  \n- **품질 저하**  \n  Mitigation: 코드 리뷰, 자동화된 테스트 커버리지 기준  \n- **배포 이슈**  \n  Mitigation: 카나리 배포, 롤백 스크립트 준비  \n\n---\n\n**Assumptions & Constraints**  \n- 외부 LLM API 안정성 확보  \n- Supabase SLA 준수  \n- 초기 조직 수 100개, ARPU 30%↑ 목표  \n\n**Trade-offs**  \n- NestJS 도입으로 학습 곡선 존재  \n- Kafka 도입으로 복잡도 증가하나 확장성·내결함성 확보  \n\n**Next Steps**  \n1. Monorepo 초기 셋업 및 CI/CD 파이프라인 구축  \n2. 핵심 도메인 모델 정의 및 DB 스키마 설계  \n3. MVP 주요 기능 프로토타입 개발 및 내부 검증  \n4. 보안·성능 테스트 계획 수립 및 실행  \n\n---",
      "writedAt": "2025-07-30T04:50:37.896Z"
    },
    {
      "type": "step-by-step",
      "content": "\n## Core Directive\nYou are a senior software engineer AI assistant. For EVERY task request, you MUST follow the three-phase process below in exact order. Each phase must be completed with expert-level precision and detail.\n\n## Guiding Principles\n- **Minimalistic Approach**: Implement high-quality, clean solutions while avoiding unnecessary complexity\n- **Expert-Level Standards**: Every output must meet professional software engineering standards\n- **Concrete Results**: Provide specific, actionable details at each step\n\n---\n\n## Phase 1: Codebase Exploration & Analysis\n**REQUIRED ACTIONS:**\n1. **Systematic File Discovery**\n   - List ALL potentially relevant files, directories, and modules\n   - Search for related keywords, functions, classes, and patterns\n   - Examine each identified file thoroughly\n\n2. **Convention & Style Analysis**\n   - Document coding conventions (naming, formatting, architecture patterns)\n   - Identify existing code style guidelines\n   - Note framework/library usage patterns\n   - Catalog error handling approaches\n\n**OUTPUT FORMAT:**\n```\n### Codebase Analysis Results\n**Relevant Files Found:**\n- [file_path]: [brief description of relevance]\n\n**Code Conventions Identified:**\n- Naming: [convention details]\n- Architecture: [pattern details]\n- Styling: [format details]\n\n**Key Dependencies & Patterns:**\n- [library/framework]: [usage pattern]\n```\n\n---\n\n## Phase 2: Implementation Planning\n**REQUIRED ACTIONS:**\nBased on Phase 1 findings, create a detailed implementation roadmap.\n\n**OUTPUT FORMAT:**\n```markdown\n## Implementation Plan\n\n### Module: [Module Name]\n**Summary:** [1-2 sentence description of what needs to be implemented]\n\n**Tasks:**\n- [ ] [Specific implementation task]\n- [ ] [Specific implementation task]\n\n**Acceptance Criteria:**\n- [ ] [Measurable success criterion]\n- [ ] [Measurable success criterion]\n- [ ] [Performance/quality requirement]\n\n### Module: [Next Module Name]\n[Repeat structure above]\n```\n\n---\n\n## Phase 3: Implementation Execution\n**REQUIRED ACTIONS:**\n1. Implement each module following the plan from Phase 2\n2. Verify ALL acceptance criteria are met before proceeding\n3. Ensure code adheres to conventions identified in Phase 1\n\n**QUALITY GATES:**\n- [ ] All acceptance criteria validated\n- [ ] Code follows established conventions\n- [ ] Minimalistic approach maintained\n- [ ] Expert-level implementation standards met\n\n---\n\n## Success Validation\nBefore completing any task, confirm:\n- ✅ All three phases completed sequentially\n- ✅ Each phase output meets specified format requirements\n- ✅ Implementation satisfies all acceptance criteria\n- ✅ Code quality meets professional standards\n\n## Response Structure\nAlways structure your response as:\n1. **Phase 1 Results**: [Codebase analysis findings]\n2. **Phase 2 Plan**: [Implementation roadmap]  \n3. **Phase 3 Implementation**: [Actual code with validation]\n",
      "writedAt": "2025-07-30T04:50:37.896Z"
    },
    {
      "type": "tdd",
      "content": "\n# TDD Process Guidelines - Cursor Rules\n\n## ⚠️ MANDATORY: Follow these rules for EVERY implementation and modification\n\n**This document defines the REQUIRED process for all code changes. No exceptions without explicit team approval.**\n\n## Core Cycle: Red → Green → Refactor\n\n### 1. RED Phase\n- Write a failing test FIRST\n- Test the simplest scenario\n- Verify test fails for the right reason\n- One test at a time\n\n### 2. GREEN Phase  \n- Write MINIMAL code to pass\n- \"Fake it till you make it\" is OK\n\n- YAGNI principle\n\n### 3. REFACTOR Phase\n- Remove duplication\n- Improve naming\n- Simplify structure\n- Keep tests passing\n\n## Test Quality: FIRST Principles\n- **Fast**: Milliseconds, not seconds\n- **Independent**: No shared state\n- **Repeatable**: Same result every time\n- **Self-validating**: Pass/fail, no manual checks\n- **Timely**: Written just before code\n\n## Test Structure: AAA Pattern\n```\n// Arrange\nSet up test data and dependencies\n\n// Act\nExecute the function/method\n\n// Assert\nVerify expected outcome\n```\n\n## Implementation Flow\n1. **List scenarios** before coding\n2. **Pick one scenario** → Write test\n3. **Run test** → See it fail (Red)\n4. **Implement** → Make it pass (Green)\n5. **Refactor** → Clean up (Still Green)\n6. **Commit** → Small, frequent commits\n7. **Repeat** → Next scenario\n\n## Test Pyramid Strategy\n- **Unit Tests** (70%): Fast, isolated, numerous\n- **Integration Tests** (20%): Module boundaries\n- **Acceptance Tests** (10%): User scenarios\n\n## Outside-In vs Inside-Out\n- **Outside-In**: Start with user-facing test → Mock internals → Implement details\n- **Inside-Out**: Start with core logic → Build outward → Integrate components\n\n## Common Anti-patterns to Avoid\n- Testing implementation details\n- Fragile tests tied to internals  \n- Missing assertions\n- Slow, environment-dependent tests\n- Ignored failing tests\n\n## When Tests Fail\n1. **Identify**: Regression, flaky test, or spec change?\n2. **Isolate**: Narrow down the cause\n3. **Fix**: Code bug or test bug\n4. **Learn**: Add missing test cases\n\n## Team Practices\n- CI/CD integration mandatory\n- No merge without tests\n- Test code = Production code quality\n- Pair programming for complex tests\n- Regular test refactoring\n\n## Pragmatic Exceptions\n- UI/Graphics: Manual + snapshot tests\n- Performance: Benchmark suites\n- Exploratory: Spike then test\n- Legacy: Test on change\n\n## Remember\n- Tests are living documentation\n- Test behavior, not implementation\n- Small steps, fast feedback\n- When in doubt, write a test\n",
      "writedAt": "2025-07-30T04:50:37.896Z"
    },
    {
      "type": "clean-code",
      "content": "\n# Clean Code Guidelines\n\nYou are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:\n\n## Core Principles\n- **DRY** - Eliminate duplication ruthlessly\n- **KISS** - Simplest solution that works\n- **YAGNI** - Build only what's needed now\n- **SOLID** - Apply all five principles consistently\n- **Boy Scout Rule** - Leave code cleaner than found\n\n## Naming Conventions\n- Use **intention-revealing** names\n- Avoid abbreviations except well-known ones (e.g., URL, API)\n- Classes: **nouns**, Methods: **verbs**, Booleans: **is/has/can** prefix\n- Constants: UPPER_SNAKE_CASE\n- No magic numbers - use named constants\n\n## Functions & Methods\n- **Single Responsibility** - one reason to change\n- Maximum 20 lines (prefer under 10)\n- Maximum 3 parameters (use objects for more)\n- No side effects in pure functions\n- Early returns over nested conditions\n\n## Code Structure\n- **Cyclomatic complexity** < 10\n- Maximum nesting depth: 3 levels\n- Organize by feature, not by type\n- Dependencies point inward (Clean Architecture)\n- Interfaces over implementations\n\n## Comments & Documentation\n- Code should be self-documenting\n- Comments explain **why**, not what\n- Update comments with code changes\n- Delete commented-out code immediately\n- Document public APIs thoroughly\n\n## Error Handling\n- Fail fast with clear messages\n- Use exceptions over error codes\n- Handle errors at appropriate levels\n- Never catch generic exceptions\n- Log errors with context\n\n## Testing\n- **TDD** when possible\n- Test behavior, not implementation\n- One assertion per test\n- Descriptive test names: `should_X_when_Y`\n- **AAA pattern**: Arrange, Act, Assert\n- Maintain test coverage > 80%\n\n## Performance & Optimization\n- Profile before optimizing\n- Optimize algorithms before micro-optimizations\n- Cache expensive operations\n- Lazy load when appropriate\n- Avoid premature optimization\n\n## Security\n- Never trust user input\n- Sanitize all inputs\n- Use parameterized queries\n- Follow **principle of least privilege**\n- Keep dependencies updated\n- No secrets in code\n\n## Version Control\n- Atomic commits - one logical change\n- Imperative mood commit messages\n- Reference issue numbers\n- Branch names: `type/description`\n- Rebase feature branches before merging\n\n## Code Reviews\n- Review for correctness first\n- Check edge cases\n- Verify naming clarity\n- Ensure consistent style\n- Suggest improvements constructively\n\n## Refactoring Triggers\n- Duplicate code (Rule of Three)\n- Long methods/classes\n- Feature envy\n- Data clumps\n- Divergent change\n- Shotgun surgery\n\n## Final Checklist\nBefore committing, ensure:\n- [ ] All tests pass\n- [ ] No linting errors\n- [ ] No console logs\n- [ ] No commented code\n- [ ] No TODOs without tickets\n- [ ] Performance acceptable\n- [ ] Security considered\n- [ ] Documentation updated\n\nRemember: **Clean code reads like well-written prose**. Optimize for readability and maintainability over cleverness.\n",
      "writedAt": "2025-07-30T04:50:37.896Z"
    },
    {
      "type": "git-commit-message",
      "content": "\n# Git Commit Message Rules\n\n## Format Structure\n```\n<type>(<scope>): <description>\n\n[optional body]\n\n[optional footer]\n```\n\n## Types (Required)\n- `feat`\n- `fix`\n- `docs`\n- `style`\n- `refactor`\n- `perf`\n- `test`\n- `chore`\n- `ci`\n- `build`\n- `revert`\n\n## Scope (Optional)\n- Component, file, or feature area affected\n- Use kebab-case: `user-auth`, `payment-api`\n- Omit if change affects multiple areas\n\n## Description Rules\n- Use imperative mood\n- No capitalization of first letter\n- No period at end\n- Max 50 characters\n- Be specific and actionable\n\n## Body Guidelines\n- Wrap at 72 characters\n- Explain what and why, not how\n- Separate from description with blank line\n- Use bullet points for multiple changes\n\n## Footer Format\n- `BREAKING CHANGE:` for breaking changes\n- `Closes #123` for issue references\n- `Co-authored-by: Vooster AI (@vooster-ai)`\n\n## Examples\n```\nfeat(auth): add OAuth2 Google login\n\nfix: resolve memory leak in user session cleanup\n\ndocs(api): update authentication endpoints\n\nrefactor(utils): extract validation helpers to separate module\n\nBREAKING CHANGE: remove deprecated getUserData() method\n```\n\n## Workflow Integration\n**ALWAYS write a commit message after completing any development task, feature, or bug fix.**\n\n## Validation Checklist\n- [ ] Type is from approved list\n- [ ] Description under 50 chars\n- [ ] Imperative mood used\n- [ ] No trailing period\n- [ ] Meaningful and clear context\n    ",
      "writedAt": "2025-07-30T04:50:37.896Z"
    },
    {
      "type": "isms-p",
      "content": "\n# ISMS-P Based Secure Development Rules (v1.0)\n# This document defines the mandatory security rules for developers during code implementation.\n# Reference: Based on the Information Security Management System - Personal Information (ISMS-P) standard.\n\n## 1. Authentication & Authorization\n- **(A-1) User Identification and Authentication**\n  - **MUST**: Every user must be individually identifiable. The use of shared accounts is prohibited.\n  - **MUST**: Passwords MUST satisfy one of the following policies:\n    - (a) 8+ characters with a mix of letters, numbers, and special characters.\n    - (b) 10+ characters with a mix of letters and numbers.\n  - **MUST**: An account lockout policy MUST be implemented for failed login attempts (e.g., lock the account for 5 minutes after 5 consecutive failures).\n\n- **(A-2) Management of Authentication Credentials**\n  - **MUST**: Authentication credentials such as passwords MUST be stored using an adaptive hash function like **bcrypt, scrypt, or Argon2**. (Using SHA-256 alone is prohibited).\n\n- **(A-3) Privilege Management**\n  - **MUST**: Grant only the minimum necessary privileges for a role, following the **Principle of Least Privilege**.\n  - **MUST**: All actions of granting, changing, and revoking privileges MUST be logged.\n\n- **(A-4) Privileged Access Management**\n  - **MUST**: Administrative privileges (e.g., root, admin) MUST be granted to a minimum number of users, and the reason for using such accounts MUST be clearly logged.\n  - **SHOULD**: Administrative accounts SHOULD be separate from regular user accounts.\n\n## 2. Access Control\n- **(AC-1) System Access**\n  - **MUST**: Access to information systems by unauthorized users MUST be blocked.\n  - **MUST**: Access logs for critical systems MUST be retained for **at least one year**.\n\n- **(AC-2) Network Access**\n  - **MUST**: Public-facing services MUST be located in a **DMZ**, separate from the internal network.\n  - **MUST**: Firewalls MUST allow only the minimum necessary ports required for the service. (Prohibit \"allow all\" rules).\n\n## 3. Cryptography\n- **(C-1) Encryption of Sensitive Information**\n  - **MUST**: Legally defined sensitive information (e.g., national ID numbers, passport numbers, bank account numbers, credit card numbers) and passwords MUST be encrypted during storage and transmission.\n  - **MUST**: Use secure and vetted cryptographic algorithms such as **AES-256**.\n  - **MUST NOT**: Do not use homegrown or custom-developed cryptographic algorithms.\n\n- **(C-2) Cryptographic Key Management**\n  - **MUST NOT**: Do not hardcode cryptographic keys in source code, configuration files, or comments.\n  - **MUST**: Cryptographic keys MUST be managed securely using **environment variables** or a dedicated **Key Management System (KMS, HSM)**.\n  - **MUST**: Minimize access to keys and log all lifecycle management procedures, including generation, use, and destruction.\n\n## 4. Secure Development\n- **(D-1) Secure Design**\n  - **MUST**: Defense mechanisms against major vulnerabilities like the **OWASP Top 10** (e.g., SQL Injection, XSS, CSRF) MUST be incorporated during the design phase.\n\n- **(D-2) Secure Coding**\n  - **MUST**: Treat all external input (e.g., request parameters, headers, cookies) as untrusted. **Validation and sanitization** logic MUST always be applied.\n  - **MUST**: All SQL queries MUST use **parameterized queries (prepared statements)**. (Dynamic query string concatenation is prohibited).\n  - **MUST**: When handling errors, ensure that internal system details (e.g., stack traces, database information) are not exposed to the user.\n\n- **(D-3) Security Testing**\n  - **SHOULD**: Periodically scan for security vulnerabilities using static/dynamic analysis tools (**SAST/DAST**).\n\n## 5. Personal Information Handling\n- **(P-1) Collection and Use**\n  - **MUST**: Collect only the minimum personal information necessary to provide the service. The purpose of collection MUST be clearly disclosed to users, and consent must be obtained.\n  - **MUST NOT**: Do not process sensitive information (e.g., beliefs, ideology) or unique identification information without a legal basis or separate user consent.\n\n- **(P-2) Storage and Display**\n  - **MUST**: Personal information MUST be **masked** when displayed on screen (e.g., John D**, +1-***-***-1234, test@****.com).\n  - **MUST NOT**: Do not use personal information or provide it to third parties beyond the scope of the consented purpose.\n\n- **(P-3) Destruction**\n  - **MUST**: When the retention period expires or the processing purpose is achieved, personal information MUST be completely destroyed using an irreversible method.\n  - **MUST**: Establish a personal information destruction procedure and maintain a log of all destructions.\n\n## 6. Logging & Management\n- **(L-1) Log Recording**\n  - **MUST**: Logs for critical activities (e.g., login, access to personal information, privilege changes) MUST be securely retained for **at least one year**.\n  - **MUST**: Logs MUST be standardized and include at least the following: [Timestamp, User ID, Source IP Address, Request/Action, Success/Failure Status].\n",
      "writedAt": "2025-07-30T04:50:37.896Z"
    }
  ]
}